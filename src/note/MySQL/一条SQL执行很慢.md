## 一条SQL执行很慢

生产环境出现一类SQL查询很慢，慢查询数超标，并且引发了连接数暴增，导致数据库响应缓慢，影响业务。

```sql
select * from sample_table where city_id = 565 and type = 13 order by id desc limit 0,1
```

表数据量达到八千多万，表中建有索引

```sql
KEY 'idx_city_id_type' ('city_id','type')
```

id 是主键

通过Explain分析SQL语句。

Explain比较重要的字段有：

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 预计需要扫描的行数

![微信图片_20201125224215](https://gitee.com/lafer/laferImage/raw/master/img/微信图片_20201125224215.png)

虽然city_id是可能走的索引但是实际走的确实主键索引。而表是千万级别，**「并且该查询条件最后实际是返回的空数据」**

指定索引查询

```sql
select * from sample_table force index(idx_city_id_type)  where ( ( (1 = 1) and (city_id = 565) ) and (type = 13) ) order by id desc limit 0, 1
```

![111](https://gitee.com/lafer/laferImage/raw/master/img/111.png)

实际执行时间0.00175714s，走了联合索引后，不再是慢查询了。

总结下来就是：**「MySQL优化器认为在limit 1的情况下，走主键索引能够更快的找到那一条数据，并且如果走联合索引需要扫描索引后进行排序，而主键索引天生有序，所以优化器综合考虑，走了主键索引。实际上，MySQL遍历了8000w条数据也没找到那个天选之人（符合条件的数据），所以浪费了很多时间。」**

#### MySQL索引选择原理

![微信图片_20201125225035](https://gitee.com/lafer/laferImage/raw/master/img/微信图片_20201125225035.png)

选择索引是MySQL优化器的工作。

而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。**优化器还会结合是否使用临时表、是否排序等因素进行综合判断。**

总结：优化器选择有许多考虑的因素：**「扫描行数、是否使用临时表、是否排序等等」**

![微信图片_20201125224215](https://gitee.com/lafer/laferImage/raw/master/img/微信图片_20201125224215.png)

![111](https://gitee.com/lafer/laferImage/raw/master/img/111.png)

走了**「主键索引」**的查询语句，rows预估行数1833，而强制走**「联合索引」**行数是45640，并且Extra信息中，显示需要Using filesort进行额外的排序。所以在不加强制索引的情况下，**「优化器选择了主键索引，因为它觉得主键索引扫描行数少，而且不需要额外的排序操作，主键索引天生有序。」**

#### rows是怎么预估出来的

explain的rows是MySQL**「预估」**的行数，**「是根据查询条件、索引和limit综合考虑出来的预估行数。」**

```sql
MySQL是怎样得到索引的基数的呢？这里，我给你简单介绍一下MySQL采样统计的方法。
为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。
采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1/M的时候，会自动触发重新做一次索引统计。
在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：
设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。
设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。
由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。
```

#### 索引要考虑 order by 的字段

为什么这么说？因为如果我这个表中的索引是`city_id`,`type`和`id`的联合索引，那优化器就会走这个联合索引，因为索引已经做好了排序。

#### 更改limit大小能解决问题？

把limit数量调大会影响预估行数rows，进而影响优化器索引的选择。

limit = 10时

![微信图片_20201125225804](https://gitee.com/lafer/laferImage/raw/master/img/微信图片_20201125225804.png)

limit = 100时

![微信图片_20201125225809](https://gitee.com/lafer/laferImage/raw/master/img/微信图片_20201125225809.png)

#### 为何突然出现异常慢查询

以前的语句查询条件返回结果都不为空，limit1很快就能找到那条数据，返回结果。而这次代码中查询条件实际结果为空，导致了扫描了全部的主键索引。

#### 解决方案

主要有两个大方向：

1. 强制指定索引
2. 干涉优化器选择

##### 强制指定索引

见效快，缺点也很明显：

- 如果有人删掉了索引会导致这条SQL查询很慢
- 高耦合，且很多代码用框架封装了SQL，`force index()`并不容易加进去。

##### 干涉优化器选择：增大limit

##### 干涉优化器选择：增加包含order by id字段的联合索引

新建`city_id`,`type`和`id`的联合索引，来解决这个问题。但是弊端就是建立索引耗时，且索引占用较大的存储空间。

##### 干涉优化器选择：写成子查询

```sql
Select * From sample_table Where id in (Select id From `newhome_db`.`af_hot_price_region` where (city_id = 565 and type = 13)) limit 0, 1
```

子查询走索引，查询id，然后id走主键索引。

但是子查询使用有风险，一版DBA也不建议使用子查询，会建议大家在代码逻辑中完成复杂的查询。当然我们这句并不复杂啦~

